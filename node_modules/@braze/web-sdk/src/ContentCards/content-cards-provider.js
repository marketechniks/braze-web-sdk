import C, { readResponseHeaders as b } from "../util/net.js";
import y from "../common/base-provider.js";
import e from "../managers/braze-instance.js";
import ContentCards from "./content-cards.js";
import { dateFromUnixTimestamp as l } from "../util/date-utils.js";
import { isURIJavascriptOrData as N } from "../util/url-utils.js";
import {
  newCardFromContentCardsJson as j,
  newCardFromSerializedValue as R,
} from "../Card/util/card-factory.js";
import r from "../../shared-lib/braze-shared-lib.js";
import { STORAGE_KEYS as i } from "../managers/storage-manager.js";
import E from "../managers/subscription-manager.js";
import s from "../common/event-logger.js";
import T from "../util/request-header-utils.js";
import { randomInclusive as D } from "../util/math.js";
import { MAX_ERROR_RETRIES_CONTENT_CARDS as S } from "../common/constants.js";
export default class v extends y {
  constructor(t, s, i, h, n) {
    super(),
      (this.wt = t),
      (this.u = s),
      (this.yt = i),
      (this.Jt = h),
      (this.$t = n),
      (this.wt = t),
      (this.u = s),
      (this.yt = i),
      (this.Jt = h),
      (this.$t = n),
      (this.Bt = new E()),
      e.Ht(this.Bt),
      (this.Kt = 0),
      (this.Qt = 0),
      (this.cards = []),
      this.Yt();
    const o = r.ts.Zt;
    new r.es(o, r.j).ss(o.rs.hs, (t) => {
      this.ns(t);
    }),
      (this.os = null),
      (this.ls = null),
      (this.us = null),
      (this.cs = null),
      (this.fs = null),
      (this.ds = 10),
      (this.ps = 0);
  }
  Cs() {
    return this.os;
  }
  ws(t) {
    this.os = t;
  }
  bs() {
    return this.ls;
  }
  vs(t) {
    this.ls = t;
  }
  Yt() {
    if (!this.u) return;
    const t = this.u.v(i.k.gs) || [],
      s = [];
    for (let i = 0; i < t.length; i++) {
      const e = R(t[i]);
      null != e && s.push(e);
    }
    (this.cards = this.ys(this.Ns(s, !1))),
      (this.Kt = this.u.v(i.k.js) || this.Kt),
      (this.Qt = this.u.v(i.k.Rs) || this.Qt);
  }
  Ts(t, s = !1, e = 0, h = 0) {
    let r;
    if (s) {
      r = [];
      for (const t of this.cards) t.test && r.push(t);
    } else r = this.cards.slice();
    for (let i = 0; i < t.length; i++) {
      const e = t[i];
      let h = null;
      for (let t = 0; t < this.cards.length; t++)
        if (e.id === this.cards[t].id) {
          h = this.cards[t];
          break;
        }
      if (s) {
        const t = j(e);
        null != h && h.viewed && t && (t.viewed = !0), null != t && r.push(t);
      } else if (null == h) {
        const t = j(e);
        null != t && r.push(t);
      } else {
        if (!h.Ct(e))
          for (let t = 0; t < r.length; t++)
            if (e.id === r[t].id) {
              r.splice(t, 1);
              break;
            }
      }
    }
    (this.cards = this.ys(this.Ns(r, s))),
      this.Ds(),
      (this.Kt = e),
      (this.Qt = h),
      this.u && (this.u.D(i.k.js, this.Kt), this.u.D(i.k.Rs, this.Qt));
  }
  Ss(t) {
    if (this.ks() && null != t && t.cards) {
      this.u && this.u.D(i.k.Us, e.As());
      const s = t.full_sync;
      s || this.Yt(),
        this.Ts(t.cards, s, t.last_full_sync_at, t.last_card_updated_at),
        this.Bt.Dt(this.Ls(!0));
    }
  }
  Fs(t) {
    this.u && this.u.D(i.k.zs, t);
  }
  Ms(t, e, h) {
    const n = () => {
        this.xs(e, h, !0);
      },
      o = t ? b(t) : null;
    let l;
    if ((this.Es(), !o || !o["retry-after"])) return void this.Fs(0);
    const a = o["retry-after"];
    if (isNaN(a) && !isNaN(Date.parse(a)))
      (l = Date.parse(a) - new Date().getTime()), l < 0 && n();
    else {
      if (isNaN(parseFloat(a.toString()))) {
        const t =
          "Received unexpected value for retry-after header in /sync response";
        return s.N(r.q.qs, { e: t + ": " + a }), void this.Fs(0);
      }
      l = 1e3 * parseFloat(a.toString());
    }
    this.us = window.setTimeout(() => {
      n();
    }, l);
    let u = 0;
    this.u && (u = this.u.v(i.k.zs)),
      (null == u || isNaN(parseInt(u.toString()))) && (u = 0),
      this.Fs(parseInt(u.toString()) + 1);
  }
  ns(t) {
    if (!this.ks()) return;
    this.Yt();
    const s = this.cards.slice();
    let i = null;
    this.wt && (i = this.wt.getUserId());
    for (let e = 0; e < t.length; e++)
      if (i === t[e].userId || (null == i && null == t[e].userId)) {
        const i = t[e].card;
        let h = null;
        for (let t = 0; t < this.cards.length; t++)
          if (i.id === this.cards[t].id) {
            h = this.cards[t];
            break;
          }
        if (null == h) {
          const t = j(i);
          null != t && s.push(t);
        } else {
          if (!h.Ct(i))
            for (let t = 0; t < s.length; t++)
              if (i.id === s[t].id) {
                s.splice(t, 1);
                break;
              }
        }
      }
    (this.cards = this.ys(this.Ns(s, !1))), this.Ds(), this.Bt.Dt(this.Ls(!0));
  }
  Ns(t, s) {
    let e = {},
      h = {},
      r = {};
    this.u &&
      ((e = this.u.v(i.k.C) || {}),
      (h = this.u.v(i.k.K) || {}),
      (r = this.u.v(i.k.G) || {}));
    const n = {},
      o = {},
      l = {};
    for (let s = 0; s < t.length; s++) {
      const i = t[s].id;
      i &&
        (e[i] && ((t[s].clicked = !0), (n[i] = !0)),
        h[i] && ((t[s].viewed = !0), (o[i] = !0)),
        r[i] && ((t[s].dismissed = !0), (l[i] = !0)));
    }
    return (
      s &&
        this.u &&
        (this.u.D(i.k.C, n), this.u.D(i.k.K, o), this.u.D(i.k.G, l)),
      t
    );
  }
  ys(t) {
    const s = [],
      e = new Date();
    let h = {};
    this.u && (h = this.u.v(i.k.G) || {});
    let n = !1;
    for (let i = 0; i < t.length; i++) {
      const o = t[i].url;
      if (!this.Jt && o && N(o)) {
        r.j.error(
          `Card with url ${o} will not be displayed because Javascript URLs are disabled. Use the "allowUserSuppliedJavascript" option for braze.initialize to enable this card.`,
        );
        continue;
      }
      const l = t[i].expiresAt;
      let a = !0;
      if ((null != l && (a = l >= e), (a = a && !t[i].dismissed), a))
        s.push(t[i]);
      else {
        const s = t[i].id;
        s && (h[s] = !0), (n = !0);
      }
    }
    return n && this.u && this.u.D(i.k.G, h), s;
  }
  Ds() {
    if (!this.u) return;
    const t = [];
    for (let s = 0; s < this.cards.length; s++) t.push(this.cards[s].tt());
    this.u.D(i.k.gs, t);
  }
  Es() {
    this.us && (clearTimeout(this.us), (this.us = null));
  }
  Is() {
    null != this.cs && (clearTimeout(this.cs), (this.cs = null));
  }
  Js(t = 1e3 * this.ds, s, i) {
    this.Is(),
      (this.cs = window.setTimeout(() => {
        this.xs(s, i, !0);
      }, t)),
      (this.fs = t);
  }
  xs(t, s, h = !1, n = !0) {
    var o;
    const l = this.$t,
      a = this.u;
    if (!l || !a) return void ("function" == typeof s && s());
    const u = !h;
    if ((u && (this.Es(), this.Fs(0)), !this.ks()))
      return void (
        this.yt &&
        this.yt.Ps(() => {
          this.xs(t, s);
        })
      );
    let c = !0;
    if (
      (u &&
        (null === (o = this.yt) || void 0 === o ? void 0 : o.$s()) &&
        (c = this._s()),
      !c)
    )
      return void r.j.info("Content card sync being throttled.");
    n && this.Is();
    const f = l.Bs({}, !0);
    a.v(i.k.Us) !== e.As() && this.Gs(),
      (f.last_full_sync_at = this.Kt),
      (f.last_card_updated_at = this.Qt);
    const d = l.Hs(f, T.Os.Ks, h);
    let m = !1;
    l.Qs(f, () => {
      if (this.u) {
        const t = new Date().valueOf();
        u && this.u.D(i.k.Vs, t), T.Ws(this.u, T.Os.Ks, t);
      }
      C.Xs({
        url: l.Ys() + "/content_cards/sync",
        data: f,
        headers: d,
        O: (i, e) => {
          if (!l.Zs(f, i, d))
            return (m = !0), void ("function" == typeof s && s());
          l.ti(),
            this.Ms(e, t, s),
            this.Ss(i),
            (m = !1),
            T.si(this.u, T.Os.Ks, 1),
            "function" == typeof t && t();
        },
        error: (t) => {
          l.ii(t, "retrieving content cards"),
            (m = !0),
            "function" == typeof s && s();
        },
        ei: () => {
          if (m && n && !this.cs && this.ps + 1 < S) {
            T.hi(this.u, T.Os.Ks);
            let i = this.fs;
            (null == i || i < 1e3 * this.ds) && (i = 1e3 * this.ds),
              this.Js(Math.min(3e5, D(1e3 * this.ds, 3 * i)), t, s),
              (this.ps = this.ps + 1);
          }
        },
      });
    });
  }
  Ls(t) {
    t || this.Yt();
    const s = this.ys(this.cards);
    s.sort((t, s) =>
      t.pinned && !s.pinned
        ? -1
        : s.pinned && !t.pinned
        ? 1
        : t.updated && s.updated && t.updated > s.updated
        ? -1
        : t.updated && s.updated && s.updated > t.updated
        ? 1
        : 0,
    );
    let e = Math.max(this.Qt || 0, this.Kt || 0);
    return (
      0 === e && (e = void 0),
      this.u && this.u.v(i.k.Rs) === this.Qt && void 0 === e && (e = this.Qt),
      new ContentCards(s, l(e))
    );
  }
  ri(t) {
    return this.Bt.It(t);
  }
  Gs() {
    (this.Kt = 0),
      (this.Qt = 0),
      this.u && (this.u.ni(i.k.js), this.u.ni(i.k.Rs));
  }
  changeUser(t) {
    t ||
      ((this.cards = []),
      this.Bt.Dt(new ContentCards(this.cards.slice(), null)),
      this.u &&
        (this.u.ni(i.k.gs),
        this.u.ni(i.k.C),
        this.u.ni(i.k.K),
        this.u.ni(i.k.G))),
      this.Gs();
  }
  clearData(t) {
    (this.Kt = 0),
      (this.Qt = 0),
      (this.cards = []),
      this.Bt.Dt(new ContentCards(this.cards.slice(), null)),
      t &&
        this.u &&
        (this.u.ni(i.k.gs),
        this.u.ni(i.k.C),
        this.u.ni(i.k.K),
        this.u.ni(i.k.G),
        this.u.ni(i.k.js),
        this.u.ni(i.k.Rs));
  }
  ks() {
    return !(this.yt && !this.yt.oi()) || (0 !== this.yt.li() && this.ai(), !1);
  }
  ui(t) {
    this.u && this.u.D(i.k.ci, t);
  }
  fi() {
    return this.u ? this.u.v(i.k.ci) : null;
  }
  _s() {
    const t = this.u,
      s = this.yt;
    if (!t || !s) return !0;
    const e = t.v(i.k.Vs);
    if (null == e || isNaN(e)) return !0;
    const h = s.di(),
      r = s.mi();
    if (-1 === h || -1 === r) return !0;
    let n = this.fi();
    (null == n || isNaN(n)) && (n = h);
    const o = (new Date().valueOf() - e) / 1e3;
    return (
      (n = Math.min(n + o / r, h)),
      !(n < 1) && ((n = Math.trunc(n) - 1), this.ui(n), !0)
    );
  }
  ai() {
    this.Bt.Dt(new ContentCards([], new Date())), this.u && this.u.ni(i.k.gs);
  }
}
