import { isDate as yt } from "../../util/code-utils.js";
import {
  convertMsToSeconds as h,
  dateFromUnixTimestamp as l,
  secondsAgo as ts,
  secondsInTheFuture as es,
} from "../../util/date-utils.js";
export default class Zt {
  constructor(t, s, e, i) {
    (this.Tl = t),
      (this.Al = s),
      (this.comparator = e),
      (this._l = i),
      (this.Tl = t),
      (this.Al = s),
      (this.comparator = e),
      (this._l = i),
      this.Al === Zt.Rl.Ml &&
        this.comparator !== Zt.Il.Ll &&
        this.comparator !== Zt.Il.Ol &&
        this.comparator !== Zt.Il.Ul &&
        this.comparator !== Zt.Il.Ql &&
        (this._l = l(this._l));
  }
  Bl(t) {
    let s = null;
    switch ((null != t && (s = t[this.Tl]), this.comparator)) {
      case Zt.Il.Xl:
        return null != s && s.valueOf() === this._l.valueOf();
      case Zt.Il.Fl:
        return null == s || s.valueOf() !== this._l.valueOf();
      case Zt.Il.Kl:
        return null != s && typeof s == typeof this._l && s > this._l;
      case Zt.Il.Ll:
        return this.Al === Zt.Rl.Ml
          ? null != s && yt(s) && ts(s) <= this._l.valueOf()
          : null != s && typeof s == typeof this._l && s >= this._l;
      case Zt.Il.Pl:
        return null != s && typeof s == typeof this._l && s < this._l;
      case Zt.Il.Ol:
        return this.Al === Zt.Rl.Ml
          ? null != s && yt(s) && ts(s) >= this._l.valueOf()
          : null != s && typeof s == typeof this._l && s <= this._l;
      case Zt.Il.Yl:
        return (
          null != s &&
          "string" == typeof s &&
          typeof s == typeof this._l &&
          null != s.match(this._l)
        );
      case Zt.Il.Zl:
        return null != s;
      case Zt.Il.$l:
        return null == s;
      case Zt.Il.Ul:
        return null != s && yt(s) && es(s) < this._l;
      case Zt.Il.Ql:
        return null != s && yt(s) && es(s) > this._l;
      case Zt.Il.Eu:
        return (
          null == s ||
          typeof s != typeof this._l ||
          "string" != typeof s ||
          null == s.match(this._l)
        );
    }
    return !1;
  }
  static fromJson(t) {
    return new Zt(
      t.property_key,
      t.property_type,
      t.comparator,
      t.property_value,
    );
  }
  tt() {
    let t = this._l;
    return (
      yt(this._l) && (t = h(t.valueOf())),
      { k: this.Tl, t: this.Al, c: this.comparator, v: t }
    );
  }
  static Yn(t) {
    return new Zt(t.k, t.t, t.c, t.v);
  }
}
(Zt.Rl = { _u: "boolean", Hu: "number", Iu: "string", Ml: "date" }),
  (Zt.Il = {
    Xl: 1,
    Fl: 2,
    Kl: 3,
    Ll: 4,
    Pl: 5,
    Ol: 6,
    Yl: 10,
    Zl: 11,
    $l: 12,
    Ul: 15,
    Ql: 16,
    Eu: 17,
  });
