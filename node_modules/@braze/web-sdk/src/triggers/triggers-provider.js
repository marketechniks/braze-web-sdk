import y from "../common/base-provider.js";
import { newInAppMessageFromJson as lt } from "../InAppMessage/in-app-message-factory.js";
import ue from "../models/braze-event.js";
import { InAppMessage } from "../InAppMessage/index.js";
import {
  isArray as p,
  isEqual as ii,
  validateValueIsFromEnum as G,
} from "../util/code-utils.js";
import { STORAGE_KEYS as i } from "../managers/storage-manager.js";
import wt from "../InAppMessage/models/templated-in-app-message.js";
import pt from "./models/trigger.js";
import tt from "./models/trigger-events.js";
import r from "../../shared-lib/braze-shared-lib.js";
export default class gr extends y {
  constructor(t, i, s, e, r) {
    super(),
      (this.tg = t),
      (this.Bt = i),
      (this.u = s),
      (this.ki = e),
      (this.ig = r),
      (this.tg = t),
      (this.Bt = i),
      (this.u = s),
      (this.ki = e),
      (this.ig = r),
      (this.sg = []),
      (this.eg = []),
      (this.hg = null),
      (this.ng = {}),
      (this.og = {}),
      (this.triggers = []),
      (this.ag = 0),
      this.lg(),
      this.gg();
  }
  fg() {
    if (this.u) {
      (this.hg = this.u.v(i.k.iE) || this.hg),
        (this.ng = this.u.v(i.k.aE) || this.ng),
        (this.og = this.u.v(i.k.nE) || this.og);
      for (let t = 0; t < this.triggers.length; t++) {
        const i = this.triggers[t];
        i.id && null != this.og[i.id] && i.Wu(this.og[i.id]);
      }
    }
  }
  lg() {
    if (!this.u) return;
    this.ag = this.u.v(i.k.oE) || 0;
    const t = this.u.v(i.k.rE) || [],
      s = [];
    for (let i = 0; i < t.length; i++) s.push(pt.Yn(t[i]));
    (this.triggers = s), this.fg();
  }
  gg() {
    const t = this,
      s = function (i, s, e, r, h) {
        return function () {
          t.cg(i, s, e, r, h);
        };
      },
      e = {};
    for (const t of this.triggers) t.id && (e[t.id] = t);
    let r = !1;
    for (let t = 0; t < this.triggers.length; t++) {
      const i = this.triggers[t];
      if (i.id && null != this.ng[i.id]) {
        const t = this.ng[i.id],
          h = [];
        for (let r = 0; r < t.length; r++) {
          const n = t[r],
            o = i.Xu(n.Zr || 0);
          if (o > 0) {
            let t, r;
            h.push(n),
              null != n.ug && (t = n.ug),
              null != n.dg && ue.TE(n.dg) && (r = ue.Yn(n.dg));
            const a = [];
            if (n.pg && p(n.pg))
              for (let t = 0; t < n.pg.length; t++) {
                const i = e[n.pg[t]];
                null != i && a.push(i);
              }
            this.eg.push(window.setTimeout(s(i, n.Zr || 0, t, r, a), o));
          }
        }
        this.ng[i.id].length > h.length &&
          ((this.ng[i.id] = h),
          (r = !0),
          0 === this.ng[i.id].length && delete this.ng[i.id]);
      }
    }
    r && this.u && this.u.D(i.k.aE, this.ng);
  }
  mg() {
    if (!this.u) return;
    const t = [];
    for (let i = 0; i < this.triggers.length; i++)
      t.push(this.triggers[i].tt());
    (this.ag = new Date().valueOf()),
      this.u.D(i.k.rE, t),
      this.u.D(i.k.oE, this.ag);
  }
  bg() {
    if (!this.u) return;
    (this.u.v(i.k.oE) || 0) > this.ag ? this.lg() : this.fg();
  }
  Ss(t) {
    let s = !1;
    if (null != t && t.triggers) {
      this.ig.mn(), this.fg();
      const e = {},
        h = {};
      this.triggers = [];
      for (let i = 0; i < t.triggers.length; i++) {
        const r = pt.fromJson(t.triggers[i]);
        if (r) {
          r.id &&
            null != this.og[r.id] &&
            (r.Wu(this.og[r.id]), (e[r.id] = this.og[r.id])),
            r.id && null != this.ng[r.id] && (h[r.id] = this.ng[r.id]);
          for (let t = 0; t < r.Vu.length; t++)
            if (r.Vu[t].ec(tt.vt, null)) {
              s = !0;
              break;
            }
          this.triggers.push(r);
        }
      }
      ii(this.og, e) || ((this.og = e), this.u && this.u.D(i.k.nE, this.og)),
        ii(this.ng, h) || ((this.ng = h), this.u && this.u.D(i.k.aE, this.ng)),
        this.mg(),
        s &&
          (r.j.info("Trigger with test condition found, firing test."),
          this.be(tt.vt)),
        this.be(tt.OPEN);
      const n = this.sg;
      let o;
      this.sg = [];
      for (let t = 0; t < n.length; t++)
        (o = Array.prototype.slice.call(n[t])), this.be(...o);
    }
  }
  cg(t, i, s, e, h) {
    const n = (e) => {
        this.fg();
        const h = new Date().valueOf();
        if (!t.Yu(i))
          return !1 === navigator.onLine && t.type === pt.Wr.Vr && e.imageUrl
            ? (r.j.info(
                `Not showing ${t.type} trigger action ${t.id} due to offline state.`,
              ),
              void this.ig.Ji(t.id, InAppMessage.Ie.Uh))
            : void (t.Uu(h) && this.wg(t, h, s)
                ? 0 === this.Bt.tc()
                  ? r.j.info(
                      `Not displaying trigger ${t.id} because neither automaticallyShowInAppMessages() nor subscribeToInAppMessage() were called.`,
                    )
                  : (this.Bt.Dt([e]), this.yg(t, h))
                : r.j.info(
                    `Not displaying trigger ${t.id} because display time fell outside of the acceptable time window.`,
                  ));
        t.type === pt.Wr.Zu
          ? this.ig.Ji(t.id, InAppMessage.Ie.Qr)
          : this.ig.Ji(t.id, InAppMessage.Ie.bh);
      },
      o = () => {
        this.fg();
        const n = h.pop();
        if (null != n)
          if ((this.Tg(n, i, s, e, h), n.Yu(i))) {
            let t = `Server aborted in-app message display, but the timeout on fallback trigger ${n.id} has already elapsed.`;
            h.length > 0 && (t += " Continuing to fall back."),
              r.j.info(t),
              this.ig.Ji(n.id, InAppMessage.Ie.bh),
              o();
          } else {
            r.j.info(
              `Server aborted in-app message display. Falling back to lower priority ${n.type} trigger action ${t.id}.`,
            );
            const o = 1e3 * n.Gu - (new Date().valueOf() - i);
            o > 0
              ? this.eg.push(
                  window.setTimeout(() => {
                    this.cg(n, i, s, e, h);
                  }, o),
                )
              : this.cg(n, i, s, e, h);
          }
      };
    let a, l, g;
    switch (t.type) {
      case pt.Wr.Vr:
        if (((a = lt(t.data)), null == a)) {
          r.j.error(
            `Could not parse trigger data for trigger ${t.id}, ignoring.`,
          ),
            this.ig.Ji(t.id, InAppMessage.Ie.Xr);
          break;
        }
        if (((l = this.ig.Mr(a)), l)) {
          r.j.error(l), o();
          break;
        }
        n(a);
        break;
      case pt.Wr.Zu:
        if (((g = wt.fromJson(t.data, n, o, i, t.sn || 0)), null == g)) {
          r.j.error(
            `Could not parse trigger data for trigger ${t.id}, ignoring.`,
          ),
            this.ig.Ji(t.id, InAppMessage.Ie.Xr);
          break;
        }
        this.ig.Hr(g, s, e);
        break;
      default:
        r.j.error(
          `Trigger ${t.id} was of unexpected type ${t.type}, ignoring.`,
        ),
          this.ig.Ji(t.id, InAppMessage.Ie.Xr);
    }
  }
  be(t, i = null, s) {
    if (!G(tt, t, "Cannot fire trigger action.", "TriggerEvents")) return;
    if (this.ki && this.ki.Du())
      return (
        r.j.info(
          "Trigger sync is currently in progress, awaiting sync completion before firing trigger event.",
        ),
        void this.sg.push(arguments)
      );
    this.bg();
    const e = new Date().valueOf(),
      h = e - (this.hg || 0);
    let n = !0,
      o = !0;
    const a = [];
    for (let s = 0; s < this.triggers.length; s++) {
      const r = this.triggers[s],
        h = e + 1e3 * r.Gu;
      if (
        r.Uu(h) &&
        (null == r.startTime || r.startTime.valueOf() <= e) &&
        (null == r.endTime || r.endTime.valueOf() >= e)
      ) {
        let s = !1;
        for (let e = 0; e < r.Vu.length; e++)
          if (r.Vu[e].ec(t, i)) {
            s = !0;
            break;
          }
        s && ((n = !1), this.wg(r, h, t) && ((o = !1), a.push(r)));
      }
    }
    if (n)
      return void r.j.info(
        `Trigger event ${t} did not match any trigger conditions.`,
      );
    if (o)
      return void r.j.info(
        `Ignoring ${t} trigger event because a trigger was displayed ${
          h / 1e3
        }s ago.`,
      );
    a.sort((t, i) => t.priority - i.priority);
    const l = a.pop();
    null != l &&
      (r.j.info(
        `Firing ${l.type} trigger action ${l.id} from trigger event ${t}.`,
      ),
      this.Tg(l, e, t, s, a),
      0 === l.Gu
        ? this.cg(l, e, t, s, a)
        : this.eg.push(
            window.setTimeout(() => {
              this.cg(l, e, t, s, a);
            }, 1e3 * l.Gu),
          ));
  }
  changeUser(t = !1) {
    if (((this.triggers = []), this.u && this.u.ni(i.k.rE), !t)) {
      (this.sg = []), (this.hg = null), (this.og = {}), (this.ng = {});
      for (let t = 0; t < this.eg.length; t++) clearTimeout(this.eg[t]);
      (this.eg = []),
        this.u && (this.u.ni(i.k.iE), this.u.ni(i.k.nE), this.u.ni(i.k.aE));
    }
  }
  clearData() {
    (this.triggers = []), (this.hg = null), (this.og = {}), (this.ng = {});
    for (let t = 0; t < this.eg.length; t++) clearTimeout(this.eg[t]);
    this.eg = [];
  }
  wg(t, i, s) {
    if (null == this.hg) return !0;
    if (s === tt.vt)
      return (
        r.j.info(
          "Ignoring minimum interval between trigger because it is a test type.",
        ),
        !0
      );
    let e = t.Ou;
    return null == e && (e = this.tg), i - this.hg >= 1e3 * e;
  }
  Tg(t, s, e, r, h) {
    this.fg(), t.id && (this.ng[t.id] = this.ng[t.id] || []);
    const n = {};
    let o;
    (n.Zr = s), (n.ug = e), null != r && (o = r.tt()), (n.dg = o);
    const a = [];
    for (const t of h) t.id && a.push(t.id);
    (n.pg = a),
      t.id && this.ng[t.id].push(n),
      this.u && this.u.D(i.k.aE, this.ng);
  }
  yg(t, s) {
    this.fg(),
      t.Wu(s),
      (this.hg = s),
      t.id && (this.og[t.id] = s),
      this.u && (this.u.D(i.k.iE, s), this.u.D(i.k.nE, this.og));
  }
}
