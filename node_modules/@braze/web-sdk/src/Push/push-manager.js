import { isArray as p, isEqual as ii } from "../util/code-utils.js";
import ti from "../models/push-token.js";
import r from "../../shared-lib/braze-shared-lib.js";
import { STORAGE_KEYS as i } from "../managers/storage-manager.js";
import { User } from "../User/index.js";
import { WindowUtils as Y } from "../util/window-utils.js";
import vt from "./utils/push-utils.js";
import { getErrorMessage as ei } from "../util/error-utils.js";
export default class ea {
  constructor(i, t, e, s, r, n, o, u, h, a) {
    (this.hn = i),
      (this.cn = t),
      (this.fn = e),
      (this.dn = r),
      (this.bn = n),
      (this.yt = o),
      (this.yn = u),
      (this.gn = h),
      (this.u = a),
      (this.hn = i),
      (this.cn = t),
      (this.fn = e),
      (this.wn = s + "/safari/" + t),
      (this.dn = r || "/service-worker.js"),
      (this.bn = n),
      (this.yt = o),
      (this.yn = u || !1),
      (this.gn = h || !1),
      (this.u = a),
      (this.vn = vt.kn()),
      (this.Pn = vt.Dn());
  }
  Sn() {
    return this.gn;
  }
  An(i, t, e, s, n) {
    i.unsubscribe()
      .then((i) => {
        i
          ? this.jn(t, e, s, n)
          : (r.j.error("Failed to unsubscribe device from push."),
            "function" == typeof n && n(!1));
      })
      .catch((i) => {
        r.j.error("Push unsubscription error: " + i),
          "function" == typeof n && n(!1);
      });
  }
  Un(i, t, e) {
    const s = ((i) => {
      if ("string" == typeof i) return i;
      if (0 !== i.endpoint.indexOf("https://android.googleapis.com/gcm/send"))
        return i.endpoint;
      let t = i.endpoint;
      const e = i;
      return (
        e.Wn &&
          -1 === i.endpoint.indexOf(e.Wn) &&
          (t = i.endpoint + "/" + e.Wn),
        t
      );
    })(i);
    let n = null,
      o = null;
    const u = i;
    if (null != u.getKey)
      try {
        const i = Array.from(new Uint8Array(u.getKey("p256dh"))),
          t = Array.from(new Uint8Array(u.getKey("auth")));
        (n = btoa(String.fromCharCode.apply(null, i))),
          (o = btoa(String.fromCharCode.apply(null, t)));
      } catch (i) {
        r.j.error(ei(i));
      }
    const h = ((i) => {
      let t;
      return i.options &&
        (t = i.options.applicationServerKey) &&
        t.byteLength &&
        t.byteLength > 0
        ? btoa(String.fromCharCode.apply(null, Array.from(new Uint8Array(t))))
            .replace(/\+/g, "-")
            .replace(/\//g, "_")
        : null;
    })(u);
    this.hn && this.hn._n(s, t, n, o, h),
      s && "function" == typeof e && e(s, n, o);
  }
  xn() {
    this.hn && this.hn.Nn(!0);
  }
  Tn(i, t) {
    this.hn && this.hn.Nn(!1), r.j.info(i), "function" == typeof t && t(!1);
  }
  zn(i, t, e, s) {
    var n;
    if ("default" === t.permission)
      try {
        window.safari.pushNotification.requestPermission(
          this.wn,
          i,
          {
            api_key: this.cn,
            device_id:
              (null === (n = this.fn) || void 0 === n ? void 0 : n.ce().id) ||
              "",
          },
          (t) => {
            "granted" === t.permission &&
              this.hn &&
              this.hn.setPushNotificationSubscriptionType(
                User.NotificationSubscriptionTypes.OPTED_IN,
              ),
              this.zn(i, t, e, s);
          },
        );
      } catch (i) {
        this.Tn("Could not request permission for push: " + i, s);
      }
    else
      "denied" === t.permission
        ? this.Tn(
            "The user has blocked notifications from this site, or Safari push is not configured in the Braze dashboard.",
            s,
          )
        : "granted" === t.permission &&
          (r.j.info("Device successfully subscribed to push."),
          this.Un(t.deviceToken, new Date(), e));
  }
  requestPermission(i, t, e) {
    const s = (s) => {
      switch (s) {
        case "granted":
          return void ("function" == typeof i && i());
        case "default":
          return void ("function" == typeof t && t());
        case "denied":
          return void ("function" == typeof e && e());
        default:
          r.j.error("Received unexpected permission result " + s);
      }
    };
    let n = !1;
    const o = window.Notification.requestPermission((i) => {
      n && s(i);
    });
    o
      ? o.then((i) => {
          s(i);
        })
      : (n = !0);
  }
  jn(i, t, e, s) {
    const n = { userVisibleOnly: !0 };
    null != t && (n.applicationServerKey = t),
      i.pushManager
        .subscribe(n)
        .then((i) => {
          r.j.info("Device successfully subscribed to push."),
            this.Un(i, new Date(), e);
        })
        .catch((i) => {
          vt.isPushBlocked()
            ? (r.j.info("Permission for push notifications was denied."),
              "function" == typeof s && s(!1))
            : (r.j.error("Push subscription failed: " + i),
              "function" == typeof s && s(!0));
        });
  }
  In() {
    return this.yn
      ? navigator.serviceWorker.getRegistration(this.dn)
      : navigator.serviceWorker.register(this.dn).then(() =>
          navigator.serviceWorker.ready.then(
            (i) => (
              i &&
                "function" == typeof i.update &&
                i.update().catch((i) => {
                  r.j.info("ServiceWorker update failed: " + i);
                }),
              i
            ),
          ),
        );
  }
  Vn(i) {
    this.yn ||
      (i.unregister(), r.j.info("Service worker successfully unregistered."));
  }
  subscribe(t, e) {
    if (!vt.isPushSupported())
      return r.j.info(ea.qn), void ("function" == typeof e && e(!1));
    if (this.vn) {
      if (!this.yn && null != window.location) {
        let i = this.dn;
        -1 === i.indexOf(window.location.host) &&
          (i = window.location.host + i),
          -1 === i.indexOf(window.location.protocol) &&
            (i = window.location.protocol + "//" + i);
        const t = i.substr(0, i.lastIndexOf("/") + 1);
        if (0 !== Y.Cn().indexOf(t))
          return (
            r.j.error(
              "Cannot subscribe to push from a path higher than the service worker location (tried to subscribe from " +
                window.location.pathname +
                " but service worker is at " +
                i +
                ")",
            ),
            void ("function" == typeof e && e(!0))
          );
      }
      if (vt.isPushBlocked())
        return void this.Tn(
          "Notifications from this site are blocked. This may be a temporary embargo or a permanent denial.",
          e,
        );
      if (this.yt && !this.yt.En() && 0 === this.yt.li())
        return (
          r.j.info(
            "Waiting for VAPID key from server config before subscribing to push.",
          ),
          void this.yt.Rn(() => {
            this.subscribe(t, e);
          })
        );
      const s = () => {
          r.j.info("Permission for push notifications was denied."),
            "function" == typeof e && e(!1);
        },
        n = () => {
          let i = "Permission for push notifications was ignored.";
          vt.isPushBlocked() &&
            (i +=
              " The browser has automatically blocked further permission requests for a period (probably 1 week)."),
            r.j.info(i),
            "function" == typeof e && e(!0);
        },
        o = vt.isPushPermissionGranted(),
        u = () => {
          !o &&
            this.hn &&
            this.hn.setPushNotificationSubscriptionType(
              User.NotificationSubscriptionTypes.OPTED_IN,
            ),
            this.In()
              .then((s) => {
                if (null == s)
                  return (
                    r.j.error(
                      "No service worker registration. Set the `manageServiceWorkerExternally` initialization option to false or ensure that your service worker is registered before calling registerPush.",
                    ),
                    void ("function" == typeof e && e(!0))
                  );
                s.pushManager
                  .getSubscription()
                  .then((n) => {
                    let o = null;
                    if (
                      (this.yt &&
                        null != this.yt.En() &&
                        (o = r.On.Fn(this.yt.En())),
                      n)
                    ) {
                      let u,
                        h = null,
                        a = null;
                      if ((this.u && (u = this.u.v(i.k.Bn)), u && !p(u))) {
                        let i;
                        try {
                          i = ti.Yn(u).Mn;
                        } catch (t) {
                          i = null;
                        }
                        null == i ||
                          isNaN(i.getTime()) ||
                          0 === i.getTime() ||
                          ((h = i),
                          (a = new Date(h)),
                          a.setMonth(h.getMonth() + 6));
                      }
                      null != o &&
                      n.options &&
                      n.options.applicationServerKey &&
                      n.options.applicationServerKey.byteLength &&
                      n.options.applicationServerKey.byteLength > 0 &&
                      !ii(o, new Uint8Array(n.options.applicationServerKey))
                        ? (n.options.applicationServerKey.byteLength > 12
                            ? r.j.info(
                                "Device was already subscribed to push using a different VAPID provider, creating new subscription.",
                              )
                            : r.j.info(
                                "Attempting to upgrade a gcm_sender_id-based push registration to VAPID - depending on the browser this may or may not result in the same gcm_sender_id-based subscription.",
                              ),
                          this.An(n, s, o, t, e))
                        : n.expirationTime &&
                          new Date(n.expirationTime).valueOf() <=
                            new Date().valueOf()
                        ? (r.j.info(
                            "Push subscription is expired, creating new subscription.",
                          ),
                          this.An(n, s, o, t, e))
                        : u && p(u)
                        ? this.An(n, s, o, t, e)
                        : null == a
                        ? (r.j.info(
                            "No push subscription creation date found, creating new subscription.",
                          ),
                          this.An(n, s, o, t, e))
                        : a.valueOf() <= new Date().valueOf()
                        ? (r.j.info(
                            "Push subscription older than 6 months, creating new subscription.",
                          ),
                          this.An(n, s, o, t, e))
                        : (r.j.info(
                            "Device already subscribed to push, sending existing subscription to backend.",
                          ),
                          this.Un(n, h, t));
                    } else this.jn(s, o, t, e);
                  })
                  .catch((i) => {
                    r.j.error(
                      "Error checking current push subscriptions: " + i,
                    );
                  });
              })
              .catch((i) => {
                r.j.error("ServiceWorker registration failed: " + i);
              });
        };
      this.requestPermission(u, n, s);
    } else if (this.Pn) {
      if (null == this.bn || "" === this.bn)
        return (
          r.j.error(
            "You must supply the safariWebsitePushId initialization option in order to use registerPush on Safari",
          ),
          void ("function" == typeof e && e(!0))
        );
      const i = window.safari.pushNotification.permission(this.bn);
      this.zn(this.bn, i, t, e);
    }
  }
  unsubscribe(i, t) {
    if (!vt.isPushSupported())
      return r.j.info(ea.qn), void ("function" == typeof t && t());
    this.vn
      ? navigator.serviceWorker.getRegistration().then((e) => {
          e
            ? e.pushManager
                .getSubscription()
                .then((s) => {
                  s &&
                    (this.xn(),
                    s
                      .unsubscribe()
                      .then((s) => {
                        s
                          ? (r.j.info(
                              "Device successfully unsubscribed from push.",
                            ),
                            "function" == typeof i && i())
                          : (r.j.error(
                              "Failed to unsubscribe device from push.",
                            ),
                            "function" == typeof t && t()),
                          this.Vn(e);
                      })
                      .catch((i) => {
                        r.j.error("Push unsubscription error: " + i),
                          "function" == typeof t && t();
                      }));
                })
                .catch((i) => {
                  r.j.error("Error unsubscribing from push: " + i),
                    "function" == typeof t && t();
                })
            : (r.j.info("Device already unsubscribed from push."),
              "function" == typeof i && i());
        })
      : this.Pn &&
        (this.xn(),
        r.j.info("Device unsubscribed from push."),
        "function" == typeof i && i());
  }
}
ea.qn = "Push notifications are not supported in this browser.";
