import ue from "../models/braze-event.js";
import _t from "../models/identifier.js";
import {
  isArray as p,
  keys as oo,
  validateValueIsFromEnum as G,
  values as Pt,
} from "../util/code-utils.js";
import r from "../../shared-lib/braze-shared-lib.js";
import { User } from "../User/index.js";
import Q from "../util/browser-detector.js";
import { getErrorMessage as ei } from "../util/error-utils.js";
export const STORAGE_KEYS = {
  eu: {
    su: "ab.storage.userId",
    Zo: "ab.storage.deviceId",
    Dl: "ab.storage.sessionId",
  },
  k: {
    Qa: "ab.test",
    tE: "ab.storage.events",
    eE: "ab.storage.attributes",
    sE: "ab.storage.attributes.anonymous_user",
    Fa: "ab.storage.device",
    Kh: "ab.storage.sdk_metadata",
    Wh: "ab.storage.session_id_for_cached_metadata",
    Bn: "ab.storage.pushToken",
    Bi: "ab.storage.newsFeed",
    Ei: "ab.storage.lastNewsFeedRefresh",
    L: "ab.storage.cardImpressions",
    hl: "ab.storage.serverConfig",
    rE: "ab.storage.triggers",
    oE: "ab.storage.triggers.ts",
    zl: "ab.storage.messagingSessionStart",
    gs: "ab.storage.cc",
    js: "ab.storage.ccLastFullSync",
    Rs: "ab.storage.ccLastCardUpdated",
    Vs: "ab.storage.ccLastClientRequest",
    ci: "ab.storage.ccRateLimitCurrentTokenCount",
    C: "ab.storage.ccClicks",
    K: "ab.storage.ccImpressions",
    G: "ab.storage.ccDismissals",
    nE: "ab.storage.lastDisplayedTriggerTimesById",
    iE: "ab.storage.lastDisplayedTriggerTime",
    aE: "ab.storage.triggerFireInstancesById",
    xh: "ab.storage.signature",
    zs: "ab.storage.brazeSyncRetryCount",
    Us: "ab.storage.sdkVersion",
    Ri: "ab.storage.ff",
    qi: "ab.storage.ffImpressions",
    Ui: "ab.storage.ffLastRefreshAt",
    EE: "ab.storage.lastReqToEndpoint",
    lE: "ab.storage.requestAttempts",
    rn: "ab.storage.deferredIam",
  },
  re: "ab.optOut",
};
export default class J {
  constructor(t, e) {
    (this.SE = t), (this._E = e), (this.SE = t), (this._E = e);
  }
  Jo(t) {
    const e = oo(STORAGE_KEYS.eu),
      s = new J.ee(t);
    for (const t of e) s.remove(STORAGE_KEYS.eu[t]);
  }
  uu(t, e) {
    let s = null;
    null != e && e instanceof _t && (s = e.tt()), this.SE.store(t, s);
  }
  uE(t) {
    const e = this.tu(t);
    null != e && ((e.Nl = new Date().valueOf()), this.uu(t, e));
  }
  tu(t) {
    return _t.Yn(this.SE.jr(t));
  }
  ql(t) {
    this.SE.remove(t);
  }
  Ho() {
    const t = oo(STORAGE_KEYS.eu);
    let e;
    for (const s of t)
      (e = this.tu(STORAGE_KEYS.eu[s])),
        null != e && this.uu(STORAGE_KEYS.eu[s], e);
  }
  bo(t) {
    let e;
    if (null == t || 0 === t.length) return !1;
    e = p(t) ? t : [t];
    let s = this._E.jr(STORAGE_KEYS.k.tE);
    (null != s && p(s)) || (s = []);
    for (let t = 0; t < e.length; t++) s.push(e[t].tt());
    return this._E.store(STORAGE_KEYS.k.tE, s);
  }
  Hl(t) {
    return null != t && this.bo([t]);
  }
  cE() {
    let t = this._E.jr(STORAGE_KEYS.k.tE);
    this._E.remove(STORAGE_KEYS.k.tE), null == t && (t = []);
    const e = [];
    let s = !1,
      o = null;
    if (p(t))
      for (let s = 0; s < t.length; s++)
        ue.TE(t[s]) ? e.push(ue.Yn(t[s])) : (o = s);
    else s = !0;
    if (s || null != o) {
      let n = "Stored events could not be deserialized as Events";
      s &&
        (n += ", was " + Object.prototype.toString.call(t) + " not an array"),
        null != o &&
          (n += ", value at index " + o + " does not look like an event"),
        (n +=
          ", serialized values were of type " +
          typeof t +
          ": " +
          JSON.stringify(t)),
        e.push(new ue(null, r.q.qs, new Date().valueOf(), null, { e: n }));
    }
    return e;
  }
  D(t, e) {
    return (
      !!G(
        STORAGE_KEYS.k,
        t,
        "StorageManager cannot store object.",
        "STORAGE_KEYS.OBJECTS",
      ) && this._E.store(t, e)
    );
  }
  v(t) {
    return (
      !!G(
        STORAGE_KEYS.k,
        t,
        "StorageManager cannot retrieve object.",
        "STORAGE_KEYS.OBJECTS",
      ) && this._E.jr(t)
    );
  }
  ni(t) {
    return (
      !!G(
        STORAGE_KEYS.k,
        t,
        "StorageManager cannot remove object.",
        "STORAGE_KEYS.OBJECTS",
      ) && (this._E.remove(t), !0)
    );
  }
  clearData() {
    const t = oo(STORAGE_KEYS.eu),
      e = oo(STORAGE_KEYS.k);
    for (let e = 0; e < t.length; e++) {
      const s = t[e];
      this.SE.remove(STORAGE_KEYS.eu[s]);
    }
    for (let t = 0; t < e.length; t++) {
      const s = e[t];
      this._E.remove(STORAGE_KEYS.k[s]);
    }
  }
  hE(t) {
    return t || STORAGE_KEYS.k.sE;
  }
  Ha(t) {
    let e = this._E.jr(STORAGE_KEYS.k.eE);
    null == e && (e = {});
    const s = this.hE(t[User.bu]),
      r = e[s];
    for (const o in t)
      o !== User.bu &&
        (null == e[s] || (r && null == r[o])) &&
        this.mu(t[User.bu], o, t[o]);
  }
  mu(t, e, s) {
    let r = this._E.jr(STORAGE_KEYS.k.eE);
    null == r && (r = {});
    const o = this.hE(t);
    let n = r[o];
    if (
      (null == n && ((n = {}), null != t && (n[User.bu] = t)), e === User.lu)
    ) {
      null == n[e] && (n[e] = {});
      for (const t in s) n[e][t] = s[t];
    } else n[e] = s;
    return (r[o] = n), this._E.store(STORAGE_KEYS.k.eE, r);
  }
  AE() {
    const t = this._E.jr(STORAGE_KEYS.k.eE);
    this._E.remove(STORAGE_KEYS.k.eE);
    const e = [];
    for (const s in t) null != t[s] && e.push(t[s]);
    return e;
  }
  ou(t) {
    const e = this._E.jr(STORAGE_KEYS.k.eE);
    if (null != e) {
      const s = this.hE(null),
        r = e[s];
      null != r &&
        ((e[s] = void 0),
        this._E.store(STORAGE_KEYS.k.eE, e),
        (r[User.bu] = t),
        this.Ha(r));
    }
    const s = this.tu(STORAGE_KEYS.eu.Dl);
    let r = null;
    null != s && (r = s.iu);
    const o = this.cE();
    if (null != o)
      for (let e = 0; e < o.length; e++) {
        const s = o[e];
        null == s.userId && s.sessionId == r && (s.userId = t), this.Hl(s);
      }
  }
  RE() {
    return this._E.OE;
  }
}
(J.Ya = class {
  constructor(t) {
    (this.cn = t), (this.cn = t), (this.OE = Q.gE() ? 3 : 10);
  }
  dE(t) {
    return t + "." + this.cn;
  }
  store(t, e) {
    const s = { v: e };
    try {
      return localStorage.setItem(this.dE(t), JSON.stringify(s)), !0;
    } catch (t) {
      return r.j.info("Storage failure: " + ei(t)), !1;
    }
  }
  jr(t) {
    try {
      let e = null;
      const s = localStorage.getItem(this.dE(t));
      return null != s && (e = JSON.parse(s)), null == e ? null : e.v;
    } catch (t) {
      return r.j.info("Storage retrieval failure: " + ei(t)), null;
    }
  }
  remove(t) {
    try {
      localStorage.removeItem(this.dE(t));
    } catch (t) {
      return r.j.info("Storage removal failure: " + ei(t)), !1;
    }
  }
}),
  (J.Za = class {
    constructor() {
      (this.fE = {}), (this.bE = 5242880), (this.OE = 3);
    }
    store(t, e) {
      const s = { value: e },
        o = this.IE(e);
      return o > this.bE
        ? (r.j.info(
            "Storage failure: object is â‰ˆ" +
              o +
              " bytes which is greater than the max of " +
              this.bE,
          ),
          !1)
        : ((this.fE[t] = s), !0);
    }
    IE(t) {
      const e = [],
        s = [t];
      let r = 0;
      for (; s.length; ) {
        const t = s.pop();
        if ("boolean" == typeof t) r += 4;
        else if ("string" == typeof t) r += 2 * t.length;
        else if ("number" == typeof t) r += 8;
        else if ("object" == typeof t && -1 === e.indexOf(t)) {
          let r, o;
          e.push(t);
          for (const e in t) (o = t), (r = e), s.push(o[r]);
        }
      }
      return r;
    }
    jr(t) {
      const e = this.fE[t];
      return null == e ? null : e.value;
    }
    remove(t) {
      this.fE[t] = null;
    }
  }),
  (J.ee = class {
    constructor(t, e) {
      (this.cn = t),
        (this.mE = e),
        (this.cn = t),
        (this.KE = this.YE()),
        (this.NE = 576e3),
        (this.mE = !!e);
    }
    dE(t) {
      return null != this.cn ? t + "." + this.cn : t;
    }
    YE() {
      let t = 0,
        e = document.location.hostname;
      const s = e.split("."),
        r = "ab._gd";
      for (; t < s.length - 1 && -1 === document.cookie.indexOf(r + "=" + r); )
        t++,
          (e = "." + s.slice(-1 - t).join(".")),
          (document.cookie = r + "=" + r + ";domain=" + e + ";");
      return (
        (document.cookie =
          r + "=;expires=" + new Date(0).toUTCString() + ";domain=" + e + ";"),
        e
      );
    }
    ae() {
      const t = new Date();
      return t.setTime(t.getTime() + 60 * this.NE * 1e3), t.getFullYear();
    }
    DE() {
      const t = Pt(STORAGE_KEYS.eu),
        e = document.cookie.split(";");
      for (let s = 0; s < e.length; s++) {
        let r = e[s];
        for (; " " === r.charAt(0); ) r = r.substring(1);
        let o = !1;
        for (let e = 0; e < t.length; e++)
          if (0 === r.indexOf(t[e])) {
            o = !0;
            break;
          }
        if (o) {
          const t = r.split("=")[0];
          -1 === t.indexOf("." + this.cn) && this.GE(t);
        }
      }
    }
    store(t, e) {
      this.DE();
      const s = new Date();
      s.setTime(s.getTime() + 60 * this.NE * 1e3);
      const o = "expires=" + s.toUTCString(),
        n = "domain=" + this.KE;
      let i;
      i = this.mE ? e : encodeURIComponent(JSON.stringify(e));
      const a = this.dE(t) + "=" + i + ";" + o + ";" + n + ";path=/";
      return a.length >= 4093
        ? (r.j.info(
            "Storage failure: string is " +
              a.length +
              " chars which is too large to store as a cookie.",
          ),
          !1)
        : ((document.cookie = a), !0);
    }
    jr(t) {
      const e = [],
        s = this.dE(t) + "=",
        o = document.cookie.split(";");
      for (let n = 0; n < o.length; n++) {
        let i = o[n];
        for (; " " === i.charAt(0); ) i = i.substring(1);
        if (0 === i.indexOf(s))
          try {
            let t;
            (t = this.mE
              ? i.substring(s.length, i.length)
              : JSON.parse(
                  decodeURIComponent(i.substring(s.length, i.length)),
                )),
              e.push(t);
          } catch (e) {
            return (
              r.j.info("Storage retrieval failure: " + ei(e)),
              this.remove(t),
              null
            );
          }
      }
      return e.length > 0 ? e[e.length - 1] : null;
    }
    remove(t) {
      this.GE(this.dE(t));
    }
    GE(t) {
      const e = t + "=;expires=" + new Date(0).toUTCString();
      (document.cookie = e), (document.cookie = e + ";path=/");
      const s = e + ";domain=" + this.KE;
      (document.cookie = s), (document.cookie = s + ";path=/");
    }
  }),
  (J.Va = class {
    constructor(t, e, s) {
      (this.cn = t),
        (this.CE = []),
        e && this.CE.push(new J.ee(t)),
        s && this.CE.push(new J.Ya(t)),
        this.CE.push(new J.Za());
    }
    store(t, e) {
      let s = !0;
      for (let r = 0; r < this.CE.length; r++) s = this.CE[r].store(t, e) && s;
      return s;
    }
    jr(t) {
      for (let e = 0; e < this.CE.length; e++) {
        const s = this.CE[e].jr(t);
        if (null != s) return s;
      }
      return null;
    }
    remove(t) {
      new J.ee(this.cn).remove(t);
      for (let e = 0; e < this.CE.length; e++) this.CE[e].remove(t);
    }
  });
