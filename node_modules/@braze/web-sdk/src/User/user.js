import {
  isArray as p,
  isDate as yt,
  isObject as Nt,
  validateValueIsFromEnum as G,
} from "../util/code-utils.js";
import r from "../../shared-lib/braze-shared-lib.js";
import {
  isValidEmail as Ct,
  validateCustomAttributeArrayType as St,
  validateCustomAttributeKey as At,
  validateCustomProperties as rt,
  validateCustomString as ot,
  validatePropertyType as Ut,
  validateStandardString as H,
} from "../util/validation-utils.js";
import { SET_CUSTOM_USER_ATTRIBUTE_STRING as Ft } from "../common/constants.js";
import { toValidBackendTimeString as $t } from "../util/date-utils.js";
export default class User {
  constructor(t, e) {
    (this.wt = t), (this.ki = e), (this.wt = t), (this.ki = e);
  }
  getUserId(t) {
    const e = this.wt.getUserId();
    if ("function" != typeof t) return e;
    r.j.warn(
      "The callback for getUserId is deprecated. You can access its return value directly instead (e.g. `const id = braze.getUser().getUserId()`)",
    ),
      t(e);
  }
  addAlias(t, e) {
    return !H(t, "add alias", "the alias", !1) || t.length <= 0
      ? (r.j.error("addAlias requires a non-empty alias"), !1)
      : !H(e, "add alias", "the label", !1) || e.length <= 0
      ? (r.j.error("addAlias requires a non-empty label"), !1)
      : this.ki.$n(t, e).O;
  }
  setFirstName(t) {
    return (
      !!H(t, "set first name", "the firstName", !0) &&
      this.wt.nu("first_name", t)
    );
  }
  setLastName(t) {
    return (
      !!H(t, "set last name", "the lastName", !0) && this.wt.nu("last_name", t)
    );
  }
  setEmail(t) {
    return null === t || Ct(t)
      ? this.wt.nu("email", t)
      : (r.j.error(
          `Cannot set email address - "${t}" did not pass RFC-5322 validation.`,
        ),
        !1);
  }
  setGender(t) {
    return (
      "string" == typeof t && (t = t.toLowerCase()),
      !(
        null !== t &&
        !G(
          User.Genders,
          t,
          `Gender "${t}" is not a valid gender.`,
          "User.Genders",
        )
      ) && this.wt.nu("gender", t)
    );
  }
  setDateOfBirth(t, e, s) {
    return null === t && null === e && null === s
      ? this.wt.nu("dob", null)
      : ((t = null != t ? parseInt(t.toString()) : null),
        (e = null != e ? parseInt(e.toString()) : null),
        (s = null != s ? parseInt(s.toString()) : null),
        null == t ||
        null == e ||
        null == s ||
        isNaN(t) ||
        isNaN(e) ||
        isNaN(s) ||
        e > 12 ||
        e < 1 ||
        s > 31 ||
        s < 1
          ? (r.j.error(
              "Cannot set date of birth - parameters should comprise a valid date e.g. setDateOfBirth(1776, 7, 4);",
            ),
            !1)
          : this.wt.nu("dob", `${t}-${e}-${s}`));
  }
  setCountry(t) {
    return !!H(t, "set country", "the country", !0) && this.wt.nu("country", t);
  }
  setHomeCity(t) {
    return (
      !!H(t, "set home city", "the homeCity", !0) && this.wt.nu("home_city", t)
    );
  }
  setLanguage(t) {
    return (
      !!H(t, "set language", "the language", !0) && this.wt.nu("language", t)
    );
  }
  setEmailNotificationSubscriptionType(t) {
    return (
      !!G(
        User.NotificationSubscriptionTypes,
        t,
        `Email notification setting "${t}" is not a valid subscription type.`,
        "User.NotificationSubscriptionTypes",
      ) && this.wt.nu("email_subscribe", t)
    );
  }
  setPushNotificationSubscriptionType(t) {
    return (
      !!G(
        User.NotificationSubscriptionTypes,
        t,
        `Push notification setting "${t}" is not a valid subscription type.`,
        "User.NotificationSubscriptionTypes",
      ) && this.wt.nu("push_subscribe", t)
    );
  }
  setPhoneNumber(t) {
    return (
      !!H(t, "set phone number", "the phoneNumber", !0) &&
      (null === t || t.match(User.Ln)
        ? this.wt.nu("phone", t)
        : (r.j.error(
            `Cannot set phone number - "${t}" did not pass validation.`,
          ),
          !1))
    );
  }
  setLastKnownLocation(t, e, s, i, n) {
    return null == t || null == e
      ? (r.j.error(
          "Cannot set last-known location - latitude and longitude are required.",
        ),
        !1)
      : ((t = parseFloat(t.toString())),
        (e = parseFloat(e.toString())),
        null != s && (s = parseFloat(s.toString())),
        null != i && (i = parseFloat(i.toString())),
        null != n && (n = parseFloat(n.toString())),
        isNaN(t) ||
        isNaN(e) ||
        (null != s && isNaN(s)) ||
        (null != i && isNaN(i)) ||
        (null != n && isNaN(n))
          ? (r.j.error(
              "Cannot set last-known location - all supplied parameters must be numeric.",
            ),
            !1)
          : t > 90 || t < -90 || e > 180 || e < -180
          ? (r.j.error(
              "Cannot set last-known location - latitude and longitude are bounded by ±90 and ±180 respectively.",
            ),
            !1)
          : (null != s && s < 0) || (null != n && n < 0)
          ? (r.j.error(
              "Cannot set last-known location - accuracy and altitudeAccuracy may not be negative.",
            ),
            !1)
          : this.ki.setLastKnownLocation(this.wt.getUserId(), t, e, i, s, n).O);
  }
  setCustomUserAttribute(t, e, s) {
    if (!At(t)) return !1;
    const i = (e) => {
      const [r] = rt(
        e,
        Ft,
        "attribute value",
        `set custom user attribute "${t}"`,
        "custom user attribute",
      );
      return r;
    };
    if (p(e)) {
      const [s, n] = St(t, e);
      if (!s && !n && 0 !== e.length) return !1;
      if (s || 0 === e.length) return this.ki.Gn(r.q.Hn, t, e).O;
      for (const t of e) if (!i(t)) return !1;
    } else if (Nt(e)) {
      if (!i(e)) return !1;
      if (s) return this.ki.Gn(r.q.Kn, t, e).O;
    } else {
      if (!(void 0 !== e && Ut(e))) return !1;
      if (
        (yt(e) && (e = $t(e)),
        "string" == typeof e &&
          !ot(
            e,
            `set custom user attribute "${t}"`,
            "the element in the given array",
          ))
      )
        return !1;
    }
    return this.wt.setCustomUserAttribute(t, e);
  }
  addToCustomAttributeArray(t, e) {
    return (
      !!ot(t, "add to custom user attribute array", "the given key") &&
      !(
        null != e &&
        !ot(e, "add to custom user attribute array", "the given value")
      ) &&
      this.ki.Gn(r.q.Jn, t, e).O
    );
  }
  removeFromCustomAttributeArray(t, e) {
    return (
      !!ot(t, "remove from custom user attribute array", "the given key") &&
      !(
        null != e &&
        !ot(e, "remove from custom user attribute array", "the given value")
      ) &&
      this.ki.Gn(r.q.Qn, t, e).O
    );
  }
  incrementCustomUserAttribute(t, e) {
    if (!ot(t, "increment custom user attribute", "the given key")) return !1;
    null == e && (e = 1);
    const s = parseInt(e.toString());
    return isNaN(s) || s !== parseFloat(e.toString())
      ? (r.j.error(
          `Cannot increment custom user attribute because the given incrementValue "${e}" is not an integer.`,
        ),
        !1)
      : this.ki.Gn(r.q.Xn, t, s).O;
  }
  setCustomLocationAttribute(t, e, s) {
    return (
      !!ot(t, "set custom location attribute", "the given key") &&
      ((null !== e || null !== s) &&
      ((e = null != e ? parseFloat(e.toString()) : null),
      (s = null != s ? parseFloat(s.toString()) : null),
      (null == e && null != s) ||
        (null != e && null == s) ||
        (null != e && (isNaN(e) || e > 90 || e < -90)) ||
        (null != s && (isNaN(s) || s > 180 || s < -180)))
        ? (r.j.error(
            "Received invalid values for latitude and/or longitude. Latitude and longitude are bounded by ±90 and ±180 respectively, or must both be null for removal.",
          ),
          !1)
        : this.ki.Zn(t, e, s).O)
    );
  }
  addToSubscriptionGroup(t) {
    return !H(
      t,
      "add user to subscription group",
      "subscription group ID",
      !1,
    ) || t.length <= 0
      ? (r.j.error(
          "addToSubscriptionGroup requires a non-empty subscription group ID",
        ),
        !1)
      : this.ki.au(t, User.du.SUBSCRIBED).O;
  }
  removeFromSubscriptionGroup(t) {
    return !H(
      t,
      "remove user from subscription group",
      "subscription group ID",
      !1,
    ) || t.length <= 0
      ? (r.j.error(
          "removeFromSubscriptionGroup requires a non-empty subscription group ID",
        ),
        !1)
      : this.ki.au(t, User.du.UNSUBSCRIBED).O;
  }
  _n(t, e, r, s, i) {
    this.wt._n(t, e, r, s, i), this.ki.pu();
  }
  Nn(t) {
    this.wt.Nn(t);
  }
}
(User.Genders = {
  MALE: "m",
  FEMALE: "f",
  OTHER: "o",
  UNKNOWN: "u",
  NOT_APPLICABLE: "n",
  PREFER_NOT_TO_SAY: "p",
}),
  (User.NotificationSubscriptionTypes = {
    OPTED_IN: "opted_in",
    SUBSCRIBED: "subscribed",
    UNSUBSCRIBED: "unsubscribed",
  }),
  (User.Ln = /^[0-9 .\\(\\)\\+\\-]+$/),
  (User.du = { SUBSCRIBED: "subscribed", UNSUBSCRIBED: "unsubscribed" }),
  (User.bu = "user_id"),
  (User.lu = "custom"),
  (User.lr = 997);
